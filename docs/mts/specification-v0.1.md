МТС — Чистовик v0.1 (единый блок спецификации)
===============================================

0) Цель
-------
Задать:
  (A) Сериализацию (EBNF) трёх нотаций: формальной, строковой (UTF-8), абитовой (четверичной: 0/1/[ /]).
  (B) Минимальные правила ядра прувера (kernel), чтобы это читалось/проверялось.
  (C) Ядро аксиом МТС — формулами в формальной нотации МТС.

Важно:
  - Круглые скобки (...) — ТОЛЬКО для приоритета/группировки в формальной нотации.
  - Квадратные скобки [ ] — ТОЛЬКО символы абитовой нотации (и UTF-8 символы, вводимые через '[]' в формальной).
  - Не использовать '-' как оператор. Для дуальности/отрицания — '!' или '¬' (синонимы).
  - В лексере токен '!->' имеет приоритет над '!' и '->'.
  - Термины "роль", "ссылка/значение" не использовать: только "смысл" и "начало/конец".


1) Три нотации (уровни ввода)
-----------------------------
1.1 Формальная нотация МТС (объектный язык; читает прувер)
  Символы/конструкторы:
    ∞            — акорень (форма полного самозамыкания)
    ♂  ...       — самозамыкание начала (префикс)
    ... ♀        — самозамыкание конца (постфикс)
    a -> b       — связь (начало a, конец b), левоассоциативна
    a !-> b      — отрицание/дуаль связи (нотация для "¬⟼"), см. аксиомы/нормализацию
    !t / ¬t      — дуальность/отрицание (унарный префикс; ! и ¬ синонимы)
    s : F        — определение (акт различения формы: "пусть знак s означает форму F")
    A = B        — тождественность (структурная неразличимость)
    A != B       — отрицание тождества (также допускаются алиасы: ≠, ¬=)
    { ... }      — пакет (контейнер) множества выражений; используется как "совместная данность"

  Принцип "всё есть связи" соблюдается так:
    - Даже (s : F) и (A = B) могут встречаться внутри других выражений, но только в скобках: (s : F), (A = B).
      Это делает "акт определения" и "факт тождества" объектами системы (их можно связывать через ->).


1.2 Строковые ачисла (UTF-8)
  Это вход "строкой символов".
  Каждый UTF-8 символ c должен быть введён формально через правило:
    'c' : T.
  Тогда строка c1 c2 ... cn интерпретируется как композиция запросов:
    decode(c1...cn) := (((decode(c1) -> decode(c2)) -> ...) -> decode(cn))
  (т.е. цепочка формальной нотации; левоассоциативность).

1.3 Абитовая (четверичная) нотация
  Алфавит РОВНО 4 символа: 0, 1, [, ].
  В этой нотации допускаются вложенные контексты вида [ ... ].
  Результат абитового парсинга затем переводится в UTF-8 строку из тех же 4 символов
  и обрабатывается правилами 1.2 (через определения '0', '1', '[', ']' в формальной нотации).


2) EBNF (сериализация)
----------------------

2.1 Формальная нотация МТС (файл теории)
----------------------------------------

Лексические соглашения:
  - пробелы/переводы строк — разделители.
  - комментарии: от '//' до конца строки (не часть языка).
  - '!->' — один токен.
  - '!=' / '≠' / '¬=' — один токен (неравенство).

EBNF:

File      ::= { Stmt } ;

Stmt      ::= Expr [ "," ] ;  // comma separator is optional

Expr      ::= DefExpr
            | EqExpr
            | NeqExpr
            | Term ;

DefExpr   ::= Term ":" Term ;

EqExpr    ::= Term "=" Term ;

NeqExpr   ::= Term NeqOp Term ;
NeqOp     ::= "!=" | "≠" | "¬=" ;

Term      ::= Chain ;

Chain     ::= Pref { LinkOp Pref } ;
LinkOp    ::= "->" | "!->" ;          // левоассоциативность задаётся парсером

Pref      ::= { NotOp | "♂" } Post ;
NotOp     ::= "!" | "¬" ;

Post      ::= Atom { "♀" | Pow } ;
Pow       ::= "^" Nat ;

Atom      ::= Const
            | Id
            | CharLit
            | Set
            | "(" Expr ")" ;

Set       ::= "{" Expr { "," Expr } "}" ;

Const     ::= "∞" | "0" | "1" ;

CharLit   ::= "'" Utf8Char "'" ;      // ровно один UTF-8 символ между апострофами

Id        ::= Letter { Letter | Digit | "_" } ;
Nat       ::= Digit { Digit } ;

2.2 Абитовая (четверичная) нотация
----------------------------------

AbitFile  ::= AbitSeq ;
AbitSeq   ::= { AbitAtom } ;
AbitAtom  ::= "0" | "1" | Ctx ;
Ctx       ::= "[" AbitSeq "]" ;

(Пример корректного AbitSeq: 01010001[010100[1001]010]... )

2.3 Строковые ачисла (UTF-8)
----------------------------
Utf8String ::= { Utf8Char } ;
(Парсер строки должен выдавать список символов; затем применяется decode по 1.2.)


3) Ядро прувера (kernel v0.1)
-----------------------------

3.1 Объекты и переменные
  - Любое Expr можно заключить в (...) и тем самым использовать как Atom внутри Term.
  - Свободные идентификаторы (Id) в аксиомах трактуются как шаблонные переменные (универсальная схема),
    если они НЕ введены ранее определением вида:  name : Term.
  - Определение вида: name : Term.
    вводит глобальный знак name как запрос по форме Term (и фиксирует его).

3.2 Нормализация (десахаризация) v0.1
  - NotOp: '!' и '¬' — синонимы (в ядре хранить один, например '!').
  - Токен '!->' — синтаксический сахар "отрицания стрелки":
      normalize(a !-> b) := normalize(!(a -> b))
    Дальнейшее поведение определяется аксиомами про '!'.

  - Степени '^n' (если включены) — синтаксический сахар:
      a^1  := a
      a^(n+1) := (a^n -> a)
    (это НЕ аксиомы, а правило развёртки на уровне парсера/нормализатора).

3.3 Доказательство как резолюция связей (минимализм МТС)
  Множество утверждений (аксиом + выведенных) хранится как "асеть выражений".
  Единственный фундаментальный шаг вывода:
    (MP) если доказано P и существует выражение (P -> Q), то доказано Q.
  Где P и Q — любые выражения (обычно в скобках: ( ... )).

  Вся "логика" (равенство, симметрия, транзитивность, конгруэнция, свойства ':')
  задаётся НЕ встроенными правилами, а аксиомами, которые создают нужные связи P -> Q.

3.4 Проверки well-formedness
  - Guarded recursion для DefExpr (s : F):
      рекурсивное упоминание s в F разрешено только под конструктором '->'
      (и/или под другими разрешёнными "охранителями", если они будут добавлены в следующих версиях).

  - Разделение нотаций:
      формальная нотация НЕ сериализуется как абитовая.
      Абитовая/строковая — только вход, который конвертируется в формальные термы.


4) Аксиомы МТС (формулы в формальной нотации МТС)
-------------------------------------------------

Примечание:
  Ниже аксиомы записаны как факты и как связи вида (P -> Q),
  чтобы ядро (через единственное правило MP) могло строить выводы.

4.0 Аксиомы определения ':'
--------------------------

// Ориентированность акта определения:
((s : F) != (F : s)).

// Порождение тождества из определения:
((s : F) -> (s = F)).

// Единственность определения (если один знак определён двумя формами, формы тождественны):
({ (s : F), (s : G) } -> (F = G)).

4.1 Аксиомы тождества '=' (как выводимые связи)
-----------------------------------------------

(x = x).
((x = y) -> (y = x)).
({ (x = y), (y = z) } -> (x = z)).

4.2 Конгруэнция и декомпозиция по конструкторам
-----------------------------------------------

// Для '->'
({ (a = c), (b = d) } -> ((a -> b) = (c -> d))).
(((a -> b) = (c -> d)) -> { (a = c), (b = d) }).

// Для '♂'
((a = b) -> (♂a = ♂b)).
((♂a = ♂b) -> (a = b)).

// Для '♀'
((a = b) -> (a♀ = b♀)).
((a♀ = b♀) -> (a = b)).

// Для '!' (дуальности)
((a = b) -> (!a = !b)).
((!a = !b) -> (a = b)).

4.3 Кванторы форм (∞, ♂, ♀) как запросы по форме
------------------------------------------------

∞ : (∞ -> ∞).
♂x : (♂x -> x).
x♀ : (x -> x♀).

4.4 Дуальность/отрицание '!' (и '¬' как синоним)
------------------------------------------------

// Инволюция:
(!!x = x).

// Инверсия направленности связи:
(!(a -> b) = (b -> a)).

// Дуальность самозамыканий:
(!(♂x) = (x♀)).
(!(x♀) = (♂x)).

// Акорень самодуален:
(!∞ = ∞).

4.5 Отрицание стрелки '!->' (как нотация для "¬⟼")
--------------------------------------------------

// '!->' — это просто "стрелка под отрицанием":
((a !-> b) = (!(a -> b))).

// (опционально, но удобно для нормализации в обе стороны)
((!(a -> b)) = (a !-> b)).

4.6 Единица смысла 1 и отсутствие смысла 0
------------------------------------------

// Единица смысла (истина / наличие различения):
1 : (♂∞ -> ∞♀).

// Нуль смысла (ложь / отсутствие различения) — как дуал 1:
0 : (!1).

// Эквивалентные явные связи (удобно как аксиомы-ярлыки):
(1 = !0).
(0 = !1).

4.7 Ввод UTF-8 символов абитовой нотации через формальную нотацию
-----------------------------------------------------------------

// Символы '[' и ']' — абиты начала/конца контекста/связи (через формы ♂∞ и ∞♀):
'[' : (♂∞).
']' : (∞♀).

// Символы '1' и '0' — абиты смысла:
'1' : 1.
'0' : 0.

4.8 Левоассоциативность цепочек (и нетождество правой группировки)
------------------------------------------------------------------

((a -> b -> c) = ((a -> b) -> c)).
((a -> (b -> c)) != ((a -> b) -> c)).

